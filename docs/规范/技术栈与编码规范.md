---
inclusion: always
priority: high
---

# BTC è‡ªåŠ¨äº¤æ˜“ç³»ç»Ÿ â€” æŠ€æœ¯æ ˆä¸ç¼–ç è§„èŒƒ

> **æ–‡æ¡£çº§åˆ«**ï¼šç¼–ç è§„èŒƒ / æ‰€æœ‰å¼€å‘å¿…é¡»éµå®ˆ  
> **å†³ç­–çŠ¶æ€**ï¼šå·²å†»ç»“  
> **é€‚ç”¨èŒƒå›´**ï¼šæ‰€æœ‰ä»£ç æ–‡ä»¶

---

## 1ï¸âƒ£ æŠ€æœ¯æ ˆé€‰å‹ï¼ˆå·²å†»ç»“ï¼‰

| ç±»åˆ« | é€‰å‹ | ç‰ˆæœ¬è¦æ±‚ | å¤‡æ³¨ |
|------|------|----------|------|
| **ç¼–ç¨‹è¯­è¨€** | Python | 3.11+ | ç”Ÿæ€ä¸°å¯Œï¼Œæ•°æ®å¤„ç†+å›æµ‹ä¾¿åˆ© |
| **Web æ¡†æ¶** | FastAPI | 0.100+ | å¼‚æ­¥ + è‡ªåŠ¨æ–‡æ¡£ |
| **å¼‚æ­¥æ¡†æ¶** | asyncio | æ ‡å‡†åº“ | ç”Ÿæ€æˆç†Ÿ |
| **æµ‹è¯•æ¡†æ¶** | pytest | 7.0+ | æ’ä»¶ä¸°å¯Œï¼Œç¤¾åŒºæ´»è·ƒ |
| **ä¾èµ–ç®¡ç†** | Poetry | 1.5+ | ç»Ÿä¸€ç®¡ç†ä¾èµ–ä¸è™šæ‹Ÿç¯å¢ƒ |
| **æ•°æ®éªŒè¯** | Pydantic | v2 | ç±»å‹å®‰å…¨ + æ•°æ®éªŒè¯ |
| **æ•°æ®åº“** | QuestDB | - | æ—¶åºæ•°æ® |
| **æ¶ˆæ¯é˜Ÿåˆ—** | Kafka | - | äº‹ä»¶æµ |

---

## 2ï¸âƒ£ é¡¹ç›®ç»“æ„ï¼ˆå·²å†»ç»“ï¼‰

```
btc-trading-system/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ core/                 # å†…æ ¸æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ state_machine.py  # å…¨å±€çŠ¶æ€æœº
â”‚   â”‚   â”œâ”€â”€ risk_control.py   # å†…æ ¸çº§é£æ§
â”‚   â”‚   â””â”€â”€ execution.py      # æ‰§è¡Œå¼•æ“
â”‚   â”‚
â”‚   â”œâ”€â”€ strategy/             # ç­–ç•¥å±‚ï¼ˆè¯äººï¼‰
â”‚   â”‚   â”œâ”€â”€ base.py           # ç­–ç•¥åŸºç±»
â”‚   â”‚   â”œâ”€â”€ witnesses/        # å„è¯äººå®ç°
â”‚   â”‚   â””â”€â”€ orchestrator.py   # ç­–ç•¥ç¼–æ’
â”‚   â”‚
â”‚   â”œâ”€â”€ data/                 # æ•°æ®å±‚
â”‚   â”‚   â”œâ”€â”€ market.py         # è¡Œæƒ…æ•°æ®
â”‚   â”‚   â”œâ”€â”€ storage.py        # æ•°æ®å­˜å‚¨
â”‚   â”‚   â””â”€â”€ replay.py         # æ•°æ®å›æ”¾
â”‚   â”‚
â”‚   â”œâ”€â”€ learning/             # è‡ªå­¦ä¹ å±‚
â”‚   â”‚   â”œâ”€â”€ analyzer.py       # åéªŒåˆ†æ
â”‚   â”‚   â””â”€â”€ optimizer.py      # æƒé‡ä¼˜åŒ–å»ºè®®
â”‚   â”‚
â”‚   â”œâ”€â”€ api/                  # REST API
â”‚   â”‚   â””â”€â”€ routes.py
â”‚   â”‚
â”‚   â””â”€â”€ common/               # å…¬å…±æ¨¡å—
â”‚       â”œâ”€â”€ models.py         # æ•°æ®æ¨¡å‹
â”‚       â”œâ”€â”€ enums.py          # æšä¸¾å®šä¹‰
â”‚       â”œâ”€â”€ exceptions.py     # è‡ªå®šä¹‰å¼‚å¸¸
â”‚       â”œâ”€â”€ logging.py        # æ—¥å¿—é…ç½®
â”‚       â””â”€â”€ config.py         # é…ç½®ç®¡ç†
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/                 # å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ integration/          # é›†æˆæµ‹è¯•
â”‚   â””â”€â”€ mocks/                # Mock å¯¹è±¡
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ dev.yaml              # å¼€å‘ç¯å¢ƒ
â”‚   â”œâ”€â”€ staging.yaml          # æµ‹è¯•ç¯å¢ƒ
â”‚   â””â”€â”€ prod.yaml             # ç”Ÿäº§ç¯å¢ƒ
â”‚
â”œâ”€â”€ scripts/                  # è„šæœ¬å·¥å…·
â”œâ”€â”€ docs/                     # æ–‡æ¡£
â”œâ”€â”€ pyproject.toml            # Poetry é…ç½®
â””â”€â”€ docker-compose.yaml       # å®¹å™¨ç¼–æ’
```

### æ¨¡å—å‘½åè§„èŒƒ

```python
# ç­–ç•¥æ¨¡å—
src/strategy/witnesses/strategy_volatility_release.py
src/strategy/witnesses/strategy_range_break.py

# é£æ§æ¨¡å—
src/core/risk_control.py
src/core/risk_validators.py

# çŠ¶æ€æœºæ¨¡å—
src/core/state_machine.py
src/core/state_transitions.py

# æ‰§è¡Œæ¨¡å—
src/core/execution.py
src/core/execution_logger.py

# å­¦ä¹ æ¨¡å—
src/learning/learning_analyzer.py
src/learning/learning_optimizer.py
```

---

## 3ï¸âƒ£ æšä¸¾å®šä¹‰ï¼ˆå·²å†»ç»“ï¼‰

```python
# src/common/enums.py

from enum import Enum

class SystemState(str, Enum):
    """ç³»ç»ŸçŠ¶æ€ï¼ˆçŠ¶æ€æœºï¼‰"""
    SYSTEM_INIT = "system_init"
    OBSERVING = "observing"
    ELIGIBLE = "eligible"
    ACTIVE_TRADING = "active_trading"
    COOLDOWN = "cooldown"
    RISK_LOCKED = "risk_locked"
    RECOVERY = "recovery"


class ClaimType(str, Enum):
    """ç­–ç•¥å£°æ˜ç±»å‹ï¼ˆç™½åå•ï¼‰"""
    MARKET_ELIGIBLE = "market_eligible"
    MARKET_NOT_ELIGIBLE = "market_not_eligible"
    REGIME_MATCHED = "regime_matched"
    REGIME_CONFLICT = "regime_conflict"
    EXECUTION_VETO = "execution_veto"


class WitnessTier(str, Enum):
    """è¯äººç­‰çº§"""
    TIER_1 = "tier_1"  # æ ¸å¿ƒè¯äººï¼šp < 0.05, èƒœç‡ 52-55%
    TIER_2 = "tier_2"  # è¾…åŠ©è¯äººï¼šp < 0.20, èƒœç‡ 51-53%
    TIER_3 = "tier_3"  # è§‚å¯Ÿçº§ï¼šp < 0.30, èƒœç‡ 50-52%
    FAIL = "fail"      # æ— æ•ˆï¼šp > 0.30 æˆ–èƒœç‡ < 50%


class WitnessSpeakingRight(str, Enum):
    """è¯äººå‘è¨€æƒç­‰çº§"""
    DISABLED = "disabled"    # ç¦æ­¢å‘è¨€
    ELIGIBLE = "eligible"    # å…è®¸å‚ä¸è£å†³
    DOMINANT = "dominant"    # å½“å‰ä¸»å¯¼èŒƒå¼ç­–ç•¥
    VETO_ONLY = "veto_only"  # ä»…å…è®¸å¦å†³æ‰§è¡Œ


class OrderSide(str, Enum):
    """è®¢å•æ–¹å‘"""
    BUY = "buy"
    SELL = "sell"


class OrderStatus(str, Enum):
    """è®¢å•çŠ¶æ€"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    FILLED = "filled"
    PARTIALLY_FILLED = "partially_filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


class RiskLevel(str, Enum):
    """é£é™©ç­‰çº§"""
    NORMAL = "normal"
    WARNING = "warning"
    COOLDOWN = "cooldown"
    RISK_LOCKED = "risk_locked"


class RiskEventType(str, Enum):
    """é£é™©äº‹ä»¶ç±»å‹"""
    DRAWDOWN_EXCEEDED = "drawdown_exceeded"
    VOLATILITY_SPIKE = "volatility_spike"
    EXECUTION_FAILURE = "execution_failure"
    REGIME_BREAKDOWN = "regime_breakdown"
    SYSTEM_ANOMALY = "system_anomaly"
```

---

## 4ï¸âƒ£ æ•°æ®æ¨¡å‹è§„èŒƒï¼ˆPydantic v2ï¼‰

```python
# src/common/models.py

from datetime import datetime
from pydantic import BaseModel, Field
from .enums import ClaimType, WitnessTier, OrderSide, OrderStatus


class Claim(BaseModel):
    """ç­–ç•¥å£°æ˜ï¼ˆç­–ç•¥å”¯ä¸€åˆæ³•è¾“å‡ºï¼‰"""
    strategy_id: str
    claim_type: ClaimType
    confidence: float = Field(ge=0.0, le=1.0)
    validity_window: int = Field(gt=0, description="æœ‰æ•ˆæ—¶é—´çª—å£ï¼ˆç§’ï¼‰")
    constraints: dict = Field(default_factory=dict)
    timestamp: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        frozen = True  # ä¸å¯å˜


class Order(BaseModel):
    """è®¢å•"""
    order_id: str
    symbol: str = "BTCUSDT"
    side: OrderSide
    quantity: float = Field(gt=0)
    price: float | None = None  # None = å¸‚ä»·å•
    status: OrderStatus = OrderStatus.PENDING
    strategy_id: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)


class ExecutionResult(BaseModel):
    """æ‰§è¡Œç»“æœ"""
    order_id: str
    status: OrderStatus
    executed_quantity: float
    executed_price: float
    timestamp: datetime
    flags: list[str] = Field(default_factory=list)


class WitnessHealth(BaseModel):
    """è¯äººå¥åº·åº¦"""
    strategy_id: str
    tier: WitnessTier
    win_rate: float = Field(ge=0.0, le=1.0)
    p_value: float = Field(ge=0.0, le=1.0)
    sample_count: int = Field(ge=0)
    sharpe_ratio: float
    max_drawdown: float
    last_updated: datetime


class RiskEvent(BaseModel):
    """é£é™©äº‹ä»¶"""
    event_id: str
    event_type: str
    level: str
    description: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
```

---

## 5ï¸âƒ£ é…ç½®ç®¡ç†è§„èŒƒ

### é…ç½®æ–‡ä»¶æ ¼å¼ï¼ˆYAML + ç¯å¢ƒå˜é‡ï¼‰

```yaml
# config/dev.yaml

system:
  name: "btc-trading-system"
  env: "dev"
  log_level: "DEBUG"

database:
  questdb:
    host: ${QUESTDB_HOST:-localhost}
    port: ${QUESTDB_PORT:-9000}
  
kafka:
  bootstrap_servers: ${KAFKA_SERVERS:-localhost:9092}
  topics:
    market_data: "market.btc.tick"
    signals: "strategy.signals"
    orders: "execution.orders"

risk_control:
  max_drawdown: 0.20          # æœ€å¤§å›æ’¤ 20%
  max_position_ratio: 0.30    # æœ€å¤§ä»“ä½ 30%
  cooldown_seconds: 300       # å†·å´æœŸ 5 åˆ†é’Ÿ

strategy:
  min_confidence: 0.60        # æœ€å°ç½®ä¿¡åº¦
  validity_window: 60         # é»˜è®¤æœ‰æ•ˆçª—å£ï¼ˆç§’ï¼‰

execution:
  retry_count: 3
  retry_delay: 1.0            # ç§’
  timeout: 30                 # ç§’
```

### é…ç½®åŠ è½½

```python
# src/common/config.py

import os
from pathlib import Path
import yaml
from pydantic import BaseSettings


class Settings(BaseSettings):
    """ç³»ç»Ÿé…ç½®"""
    env: str = "dev"
    config_path: Path = Path("config")
    
    def load_config(self) -> dict:
        config_file = self.config_path / f"{self.env}.yaml"
        with open(config_file) as f:
            config = yaml.safe_load(f)
        # ç¯å¢ƒå˜é‡æ›¿æ¢
        return self._resolve_env_vars(config)
    
    @staticmethod
    def _resolve_env_vars(config: dict) -> dict:
        # é€’å½’æ›¿æ¢ ${VAR:-default} æ ¼å¼
        ...


settings = Settings()
config = settings.load_config()
```

---

## 6ï¸âƒ£ æ—¥å¿—è§„èŒƒï¼ˆç»“æ„åŒ– JSONï¼‰

```python
# src/common/logging.py

import logging
import json
from datetime import datetime


class JSONFormatter(logging.Formatter):
    """ç»“æ„åŒ– JSON æ—¥å¿—æ ¼å¼"""
    
    def format(self, record):
        log_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "module": record.module,
            "function": record.funcName,
            "message": record.getMessage(),
        }
        
        # æ·»åŠ é¢å¤–å­—æ®µ
        if hasattr(record, "extra"):
            log_data.update(record.extra)
        
        # æ·»åŠ å¼‚å¸¸ä¿¡æ¯
        if record.exc_info:
            log_data["exception"] = self.formatException(record.exc_info)
        
        return json.dumps(log_data, ensure_ascii=False)


def get_logger(name: str) -> logging.Logger:
    """è·å–ç»“æ„åŒ–æ—¥å¿—å™¨"""
    logger = logging.getLogger(name)
    handler = logging.StreamHandler()
    handler.setFormatter(JSONFormatter())
    logger.addHandler(handler)
    return logger


# ä½¿ç”¨ç¤ºä¾‹
logger = get_logger("execution")
logger.info("è®¢å•æ‰§è¡Œ", extra={
    "order_id": "O-001",
    "side": "buy",
    "quantity": 0.1,
    "price": 82500
})
```

### æ—¥å¿—è¾“å‡ºç¤ºä¾‹

```json
{
  "timestamp": "2026-01-30T10:00:00.000Z",
  "level": "INFO",
  "module": "execution",
  "function": "execute_order",
  "message": "è®¢å•æ‰§è¡Œ",
  "order_id": "O-001",
  "side": "buy",
  "quantity": 0.1,
  "price": 82500
}
```

---

## 7ï¸âƒ£ å¼‚å¸¸å¤„ç†è§„èŒƒ

```python
# src/common/exceptions.py

class TradingSystemError(Exception):
    """äº¤æ˜“ç³»ç»ŸåŸºç¡€å¼‚å¸¸"""
    pass


# ç­–ç•¥å±‚å¼‚å¸¸
class StrategyError(TradingSystemError):
    """ç­–ç•¥å¼‚å¸¸"""
    pass


class InvalidClaimError(StrategyError):
    """æ— æ•ˆå£°æ˜"""
    pass


# é£æ§å±‚å¼‚å¸¸
class RiskControlError(TradingSystemError):
    """é£æ§å¼‚å¸¸"""
    pass


class RiskLockedException(RiskControlError):
    """ç³»ç»Ÿå·²è¢«é£æ§é”å®š"""
    pass


# æ‰§è¡Œå±‚å¼‚å¸¸
class ExecutionError(TradingSystemError):
    """æ‰§è¡Œå¼‚å¸¸"""
    pass


class OrderRejectedError(ExecutionError):
    """è®¢å•è¢«æ‹’ç»"""
    pass


class OrderTimeoutError(ExecutionError):
    """è®¢å•è¶…æ—¶"""
    pass


# æ•°æ®å±‚å¼‚å¸¸
class DataError(TradingSystemError):
    """æ•°æ®å¼‚å¸¸"""
    pass


class DataNotFoundError(DataError):
    """æ•°æ®æœªæ‰¾åˆ°"""
    pass


# çŠ¶æ€æœºå¼‚å¸¸
class StateMachineError(TradingSystemError):
    """çŠ¶æ€æœºå¼‚å¸¸"""
    pass


class InvalidStateTransitionError(StateMachineError):
    """éæ³•çŠ¶æ€è½¬æ¢"""
    pass
```

### å¼‚å¸¸å¤„ç†æ¨¡å¼

```python
# âœ… æ¨èçš„å¼‚å¸¸å¤„ç†

from src.common.exceptions import (
    RiskLockedException,
    OrderRejectedError,
    InvalidStateTransitionError
)

async def execute_trade(order: Order):
    try:
        # æ£€æŸ¥é£æ§
        if not risk_control.check_permission():
            raise RiskLockedException("ç³»ç»Ÿå·²è¢«é£æ§é”å®š")
        
        # æ£€æŸ¥çŠ¶æ€
        if state_machine.current_state != SystemState.ELIGIBLE:
            raise InvalidStateTransitionError(
                f"å½“å‰çŠ¶æ€ {state_machine.current_state} ä¸å…è®¸äº¤æ˜“"
            )
        
        # æ‰§è¡Œè®¢å•
        result = await execution_engine.execute(order)
        return result
        
    except RiskLockedException:
        logger.warning("äº¤æ˜“è¢«é£æ§æ‹’ç»", extra={"order_id": order.order_id})
        raise
        
    except OrderRejectedError as e:
        logger.error("è®¢å•è¢«æ‹’ç»", extra={
            "order_id": order.order_id,
            "reason": str(e)
        })
        raise
```

---

## 8ï¸âƒ£ é‡è¯•ç­–ç•¥è§„èŒƒ

```python
# src/common/retry.py

import asyncio
from functools import wraps
from typing import Type


def retry_with_backoff(
    max_retries: int = 3,
    base_delay: float = 1.0,
    exponential: bool = True,
    exceptions: tuple[Type[Exception], ...] = (Exception,)
):
    """
    é‡è¯•è£…é¥°å™¨
    
    - æ ¸å¿ƒ I/Oï¼šæŒ‡æ•°é€€é¿
    - äº¤æ˜“æ¥å£ï¼šå›ºå®šé—´éš”ï¼ˆé˜²æ­¢é‡å¤ä¸‹å•ï¼‰
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            last_exception = None
            
            for attempt in range(max_retries):
                try:
                    return await func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e
                    
                    if attempt < max_retries - 1:
                        if exponential:
                            delay = base_delay * (2 ** attempt)
                        else:
                            delay = base_delay
                        
                        logger.warning(f"é‡è¯• {attempt + 1}/{max_retries}", extra={
                            "function": func.__name__,
                            "delay": delay,
                            "error": str(e)
                        })
                        
                        await asyncio.sleep(delay)
            
            raise last_exception
        
        return wrapper
    return decorator


# ä½¿ç”¨ç¤ºä¾‹

# æ ¸å¿ƒ I/Oï¼šæŒ‡æ•°é€€é¿
@retry_with_backoff(max_retries=3, exponential=True)
async def fetch_market_data():
    ...

# äº¤æ˜“æ¥å£ï¼šå›ºå®šé—´éš”ï¼ˆé˜²æ­¢é‡å¤ä¸‹å•ï¼‰
@retry_with_backoff(max_retries=2, base_delay=2.0, exponential=False)
async def place_order(order: Order):
    ...
```

---

## 9ï¸âƒ£ å¹¶å‘è§„èŒƒ

### asyncio åç¨‹æ¨¡å¼

```python
# âœ… æ¨èçš„å¹¶å‘æ¨¡å¼

import asyncio
from asyncio import Lock


class ExecutionEngine:
    """æ‰§è¡Œå¼•æ“ï¼ˆå¹¶å‘å®‰å…¨ï¼‰"""
    
    def __init__(self):
        self._lock = Lock()
        self._order_queue: asyncio.Queue = asyncio.Queue()
    
    async def execute(self, order: Order) -> ExecutionResult:
        """æ‰§è¡Œè®¢å•ï¼ˆåŠ é”ä¿è¯é¡ºåºï¼‰"""
        async with self._lock:
            # æ£€æŸ¥é£æ§
            if not await self._check_risk():
                raise RiskLockedException()
            
            # æ‰§è¡Œè®¢å•
            result = await self._place_order(order)
            
            # è®°å½•æ—¥å¿—
            await self._log_execution(order, result)
            
            return result
    
    async def _check_risk(self) -> bool:
        """æ£€æŸ¥é£æ§ï¼ˆä¸èƒ½ç»•è¿‡ï¼‰"""
        return risk_control.check_permission()
    
    async def _place_order(self, order: Order) -> ExecutionResult:
        """ä¸‹å•åˆ°äº¤æ˜“æ‰€"""
        ...
    
    async def _log_execution(self, order: Order, result: ExecutionResult):
        """è®°å½•æ‰§è¡Œæ—¥å¿—ï¼ˆå¿…é¡»ï¼‰"""
        ...
```

### åˆ†å¸ƒå¼é”ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰

```python
# ç”Ÿäº§ç¯å¢ƒä½¿ç”¨ Redis åˆ†å¸ƒå¼é”

import redis.asyncio as redis
from contextlib import asynccontextmanager


class DistributedLock:
    """åˆ†å¸ƒå¼é”ï¼ˆRedisï¼‰"""
    
    def __init__(self, redis_client: redis.Redis):
        self._redis = redis_client
    
    @asynccontextmanager
    async def acquire(self, key: str, timeout: int = 30):
        """è·å–é”"""
        lock_key = f"lock:{key}"
        
        # å°è¯•è·å–é”
        acquired = await self._redis.set(
            lock_key, "1", nx=True, ex=timeout
        )
        
        if not acquired:
            raise RuntimeError(f"æ— æ³•è·å–é”: {key}")
        
        try:
            yield
        finally:
            await self._redis.delete(lock_key)


# ä½¿ç”¨ç¤ºä¾‹
async def execute_order_distributed(order: Order):
    async with distributed_lock.acquire(f"order:{order.symbol}"):
        result = await execution_engine.execute(order)
        return result
```

---

## ğŸ”Ÿ æµ‹è¯•è§„èŒƒ

### è¦†ç›–ç‡è¦æ±‚

| æ¨¡å— | æœ€ä½è¦†ç›–ç‡ | è¯´æ˜ |
|------|-----------|------|
| core/ | 90% | å†…æ ¸æ¨¡å—å¿…é¡»é«˜è¦†ç›– |
| strategy/ | 80% | ç­–ç•¥æ¨¡å— |
| data/ | 80% | æ•°æ®æ¨¡å— |
| learning/ | 70% | è‡ªå­¦ä¹ æ¨¡å— |
| api/ | 70% | API æ¨¡å— |

### Mock ç­–ç•¥

```python
# tests/mocks/exchange.py

from unittest.mock import AsyncMock
from src.common.models import Order, ExecutionResult, OrderStatus


class MockExchange:
    """Mock äº¤æ˜“æ‰€"""
    
    def __init__(self):
        self.orders: list[Order] = []
        self.place_order = AsyncMock(side_effect=self._place_order)
        self.cancel_order = AsyncMock(side_effect=self._cancel_order)
    
    async def _place_order(self, order: Order) -> ExecutionResult:
        self.orders.append(order)
        return ExecutionResult(
            order_id=order.order_id,
            status=OrderStatus.FILLED,
            executed_quantity=order.quantity,
            executed_price=order.price or 82500.0,
            timestamp=datetime.utcnow(),
            flags=[]
        )
    
    async def _cancel_order(self, order_id: str) -> bool:
        return True


# ä½¿ç”¨ç¤ºä¾‹
@pytest.fixture
def mock_exchange():
    return MockExchange()


async def test_execute_order(mock_exchange):
    engine = ExecutionEngine(exchange=mock_exchange)
    order = Order(...)
    result = await engine.execute(order)
    
    assert result.status == OrderStatus.FILLED
    assert mock_exchange.place_order.called
```

### é›†æˆæµ‹è¯•

```python
# tests/integration/test_trading_flow.py

import pytest
from src.core.state_machine import StateMachine
from src.core.risk_control import RiskControl
from src.core.execution import ExecutionEngine


@pytest.mark.integration
async def test_full_trading_flow():
    """ç«¯åˆ°ç«¯æµ‹è¯•ï¼šç­–ç•¥ â†’ é£æ§ â†’ æ‰§è¡Œ â†’ æ•°æ®"""
    
    # 1. åˆå§‹åŒ–
    state_machine = StateMachine()
    risk_control = RiskControl()
    execution = ExecutionEngine(exchange=mock_exchange)
    
    # 2. ç­–ç•¥ç”Ÿæˆ Claim
    claim = Claim(
        strategy_id="volatility_release",
        claim_type=ClaimType.MARKET_ELIGIBLE,
        confidence=0.75,
        validity_window=60
    )
    
    # 3. çŠ¶æ€æœºå¤„ç†
    assert state_machine.current_state == SystemState.OBSERVING
    state_machine.process_claim(claim)
    assert state_machine.current_state == SystemState.ELIGIBLE
    
    # 4. é£æ§æ£€æŸ¥
    assert risk_control.check_permission() == True
    
    # 5. æ‰§è¡Œäº¤æ˜“
    order = Order(...)
    result = await execution.execute(order)
    
    # 6. éªŒè¯ç»“æœ
    assert result.status == OrderStatus.FILLED
    assert state_machine.current_state == SystemState.COOLDOWN
```

---

## 1ï¸âƒ£1ï¸âƒ£ æ—¶é—´å¤„ç†è§„èŒƒ

```python
# âœ… æ‰€æœ‰æ—¶é—´ä½¿ç”¨ UTC

from datetime import datetime, timezone


def utc_now() -> datetime:
    """è·å–å½“å‰ UTC æ—¶é—´"""
    return datetime.now(timezone.utc)


def to_utc(dt: datetime) -> datetime:
    """è½¬æ¢ä¸º UTC"""
    if dt.tzinfo is None:
        return dt.replace(tzinfo=timezone.utc)
    return dt.astimezone(timezone.utc)


def to_local(dt: datetime, tz: timezone) -> datetime:
    """è½¬æ¢ä¸ºæœ¬åœ°æ—¶é—´ï¼ˆä»…ç”¨äºå±•ç¤ºï¼‰"""
    return dt.astimezone(tz)


# âŒ ç¦æ­¢ä½¿ç”¨
datetime.now()  # æœ¬åœ°æ—¶é—´ï¼Œä¸æ˜ç¡®

# âœ… æ¨èä½¿ç”¨
datetime.now(timezone.utc)  # UTC æ—¶é—´
utc_now()  # å°è£…å‡½æ•°
```

---

## 1ï¸âƒ£2ï¸âƒ£ ä»£ç é£æ ¼æ£€æŸ¥

### å·¥å…·é…ç½®

```toml
# pyproject.toml

[tool.black]
line-length = 88
target-version = ['py311']

[tool.isort]
profile = "black"
line_length = 88

[tool.mypy]
python_version = "3.11"
strict = true
ignore_missing_imports = true

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]
addopts = "--cov=src --cov-report=term-missing"
```

### Pre-commit é…ç½®

```yaml
# .pre-commit-config.yaml

repos:
  - repo: https://github.com/psf/black
    rev: 23.7.0
    hooks:
      - id: black

  - repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
      - id: isort

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.4.1
    hooks:
      - id: mypy
        additional_dependencies: [pydantic]
```

---

## ğŸ“‹ ç¼–ç å‰æ£€æŸ¥æ¸…å•

åœ¨å¼€å§‹ç¼–ç å‰ï¼Œç¡®è®¤ï¼š

- [ ] ä½¿ç”¨ Python 3.11+
- [ ] ä½¿ç”¨ Poetry ç®¡ç†ä¾èµ–
- [ ] ä½¿ç”¨ Pydantic v2 å®šä¹‰æ•°æ®æ¨¡å‹
- [ ] ä½¿ç”¨ asyncio å¤„ç†å¹¶å‘
- [ ] ä½¿ç”¨ç»“æ„åŒ– JSON æ—¥å¿—
- [ ] ä½¿ç”¨ UTC æ—¶é—´
- [ ] ä½¿ç”¨è‡ªå®šä¹‰å¼‚å¸¸ç±»
- [ ] éµå®ˆé¡¹ç›®ç›®å½•ç»“æ„
- [ ] éµå®ˆæšä¸¾å®šä¹‰
- [ ] éµå®ˆå‘½åè§„èŒƒ

---

**è®°ä½ï¼šæŠ€æœ¯é€‰å‹å·²å†»ç»“ï¼Œä¸è¦å¼•å…¥æœªç»æ‰¹å‡†çš„ä¾èµ–ã€‚**
